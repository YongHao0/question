### 群已读消息列表问题

#### 现有方案

`注意:` 此方案三端实现的逻辑都是相同的, 逻辑正确, 则消息量也是相同的

`产品逻辑`: 消息点击查看后, 才可查看已读人员列表

*基本逻辑:*

1、群组中用户 A 发送消息后, 点击消息的 查看已读成员列表 时, 向群组中发送消息(ReadReceiptRequestMessage), 告诉群组其他成员, A 需要知道你们是否读了这条消息

2、群组中用户 B、C、D、E ...... 收到步骤 1 中用户 A 发送的消息后, 向用户 A 发送消息(ReadReceiptResponseMessage), 告诉用户 A, 我已经读了你发的这条消息

*存储方式:*

此方案需 PC 端自行做存储处理, 存储如下:

1、A 发送 ReadReceiptRequestMessage 后, 需记录 A 需要看这条消息是否已读的标识

2、A 收到其他用户(例如 B)发送的 ReadReceiptResponseMessage 后, 需更新 1 中的标识, 记录 B 已读了这条消息

#### 新方案

*基本逻辑:*

结合 App Server 实现, 以群成员在群中的已读时间做判断

1、App Server 存储的群成员信息新加字段 last_read_time, 该字段表示该成员在该群中最后读取消息的时间, 群中该时间以前的消息对该成员来说都算为已读

2、App Server 暴露接口 setLastReadTime, 设置成员在该群中最后读取消息的时间

3、客户端用户 B 进会话, 读消息时, 调用 setLastReadTime

4、客户端进入会话, 获取群成员, 根据所有成员的 last_read_time, 得出消息的已读人员列表

```js
例如:
群组中包含: A、B、C
A 进入会话, 获取群成员, 得到 B.last_read_time = 时间1, C.last_read_time = 时间2
获取历史消息, 比如有消息 M, 比较 M.sentTime 和 时间 1, 如 M.sentTime < 时间 1, 说明 B 已读
```

5、App Server 实现的接口 setLastReadTime, 设置读取时间后, 向发送消息方(可发定向消息)发一条通知消息(可自定义, 不存储、不计数)

6、发送消息方收到通知消息后, 更新本地消息已读列表(此操作用于列表实时更新)

7、离线的通知消息, 不需要进行任何处理

*优点:*

1、客户端本地不需要进行存储

2、因已读时间为成员最后读取时间, 不需读取每条消息都发送回执, 消息量相比旧方案较少

3、离线消息不需要处理

*缺点:*

1、客户端代码需做逻辑转换, 通过成员最后已读的时间, 得出消息的已读列表

2、需三端同时修改